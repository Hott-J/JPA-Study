# JPA

## Why JPA?

- 지금 시대는 객체를 관계형 DB에 관리
  - SQL 중심적인 개발
- SQL 중심적인 개발의 문제점
  - 무한 반복, 지루한 코드
  - 객체 CRUD 필드 추가하려면 많은 쿼리들을 update 해야함
  - 객체를 관계형 DB에 저장? -> SQL을 사용해야함
  - 객체와 관계형 DB의 차이
    - 상속
      - DB는 없다
      - 그나마 테이블의 슈퍼타입 서브타입 관계와 유사
    - 연관관계
      - DB는 PK, FK 로 join해서 찾을 수 있다
      - DB는 양방향, 객체는 단방향
  - 자바 컬렉션에 저장하는 것이 SQL 로 조회하는 것보다 훨씬 좋다
    - SQL join을 일일이 해줘야한다
  - 객체답게 모델링 할수록 매핑 작업만 늘어난다
  - 객체를 자바 컬렉션에 저장 하듯이 DB에 저장할 수는 없을까? -> JPA

## 영속성 관리

- 객체와 RDMBS 매핑
- 영속성 컨텍스트
  - 엔티티를 영구적으로 저장하는 환경
  - 눈에 보이는 개념이 아님
  - 엔티티 매니저를 통해서 접근
- 생명주기
  - 비영속
    - 아무것도 아닐때
  - 영속
    - 객체를 저장 / 가져올 때
    - em.persist(member) / em.find(member)
  - 준영속
    - 영속성 컨텍스트에서 분리 / 객체 삭제
    - em.detach(member) / em.remove(member)
- 이점
  - 1차 캐시
    - 한번 조회했던거 또 조회하면 쿼리 안날라감
      - 동일 트랜잭션 안에서, 10명 고객이 동시접근하면 별도 캐시 가지므로 성능상 큰 이점은 없다.
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
    - 버퍼링, 한번에 write
  - 변경 감지
    - update, 변경된걸 JPA가 자동으로 인식
  - 지연 로딩
- 플러시
  - 기본값인 AUTO 사용한다
  - 영속성 컨텍스트를 비우지 않음
  - 영속성 컨텍스트의 변경내용을 DB에 동기화
  - 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화하면 됨(중요)
  - 영속성 컨텍스트 시작 끝 주기와 트랜잭션 시작 끝 주기를 맞추는게 데이터 동기화 문제가 없어 좋다
