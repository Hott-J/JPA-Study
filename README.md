# JPA

## Why JPA?

- 지금 시대는 객체를 관계형 DB에 관리
  - SQL 중심적인 개발
- SQL 중심적인 개발의 문제점
  - 무한 반복, 지루한 코드
  - 객체 CRUD 필드 추가하려면 많은 쿼리들을 update 해야함
  - 객체를 관계형 DB에 저장? -> SQL을 사용해야함
  - 객체와 관계형 DB의 차이
    - 상속
      - DB는 없다
      - 그나마 테이블의 슈퍼타입 서브타입 관계와 유사
    - 연관관계
      - DB는 PK, FK 로 join해서 찾을 수 있다
      - DB는 양방향, 객체는 단방향
  - 자바 컬렉션에 저장하는 것이 SQL 로 조회하는 것보다 훨씬 좋다
    - SQL join을 일일이 해줘야한다
  - 객체답게 모델링 할수록 매핑 작업만 늘어난다
  - 객체를 자바 컬렉션에 저장 하듯이 DB에 저장할 수는 없을까? -> JPA

## 영속성 관리

- 객체와 RDMBS 매핑
- 영속성 컨텍스트
  - 엔티티를 영구적으로 저장하는 환경
  - 눈에 보이는 개념이 아님
  - 엔티티 매니저를 통해서 접근
- 생명주기
  - 비영속
    - 아무것도 아닐때
  - 영속
    - 객체를 저장 / 가져올 때
    - em.persist(member) / em.find(member)
  - 준영속
    - 영속성 컨텍스트에서 분리 / 객체 삭제
    - em.detach(member) / em.remove(member)
- 이점
  - 1차 캐시
    - 한번 조회했던거 또 조회하면 쿼리 안날라감
      - 동일 트랜잭션 안에서, 10명 고객이 동시접근하면 별도 캐시 가지므로 성능상 큰 이점은 없다.
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
    - 버퍼링, 한번에 write
  - 변경 감지
    - update, 변경된걸 JPA가 자동으로 인식
  - 지연 로딩
- 플러시

  - 기본값인 AUTO 사용한다
  - 영속성 컨텍스트를 비우지 않음
  - 영속성 컨텍스트의 변경내용을 DB에 동기화
  - 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화하면 됨(중요)
  - 영속성 컨텍스트 시작 끝 주기와 트랜잭션 시작 끝 주기를 맞추는게 데이터 동기화 문제가 없어 좋다

  ## 엔티티 매핑

  - GeneratedValue

    - Identity 전략에 한해서, pk값을 알아내기 위해 em.persist 때 DB에 접근해서 insert 쿼리문을 날린다. insert 쿼리를 날리면서 id 값을 알아낸다. 그래서 모아서 보내는게 identity 전략에서는 불가능하다. em.persist를 하기 위해서는 pk값이 필수로 있어야한다.

    - Sequence 전략이면, DB에서 pk값을 시퀀스 값을 보고 우선적으로 얻어온다. em.persist때 insert문이 나가지 않는다. 버퍼링 방식이 가능하다. 매번 pk값을 얻어오려고 네트워크를 통해 next value 값을 얻어오는건 성능상 비효율적. 개선을 위해 allocationSize를 통해 50을 두면 DB에 50까지 미리 넣어놓고, 메모리에서 1~50까지 쓰다가 50이 되면 다시 DB에 100까지 넣고 메모리에서 51~100. 이를 반복하여 성능 개선. 여러개 동시에 호출하더라도 문제 없다. 동시 호출하면 쭉 값이 올라감. 동시 호출하더라도 숫자를 자기가 미리 확보.
